from matrix import *
from mathFuncs import *
from cyphers import *

def T1_recursive_binary_search():
    """
    В начале алгоритма требуется указать выход из рекурсии, чтобы при вызове функции происходила проверка и в случае ее
    успеха лишние действия не выполнялись. Рекурсивный бинарный поиск - такой же поиск как и через циклы. Разница лишь в
    том, что вместо очередной итерации мы вызываем функцию, передаем ей параметры границ и меняем те границы, которые требуется.
    """
    print('##### Рекурсивный бинарный поиск #####\n')
    line = determination_binary_search()
    print(line)
    print('\n' + '#'*20)


def T2_decimal_to_binary():
    """
    Запоминаем знак числа, берем его модуль. Ищем остаток от деление на 2 до тех пор пока делимое больше 0. При каждой
    новой итерации делимым становится результат деления нацело с делителем 2.
    """
    print('##### Перевод в двоичную систему #####\n')
    decimal = decimal_determination()
    binary = decimal_to_binary(decimal)
    print(f'{decimal} в двоичной системе -> {binary}')
    print('\n' + '#' * 20)


def T3_isPrime():
    """
    Простое число - натуральное число, которое имеет лишь два делителя: 1 и оно само. Наименьшим простым числом является 1.
    Для того, чтобы узнать простое ли число. Взяв натуральные числа отсеиваем 1, как исключение. Далее требуется узнать,
    равняется ли загаданное число 2 или 3. Эти числа тоже являются простыми. Требуется сразу исключить все четные и кратные 3
    числа. После чего требуется найти делители загаданного числа среди нечетных чисел от 5 и до квадрата нашего числа
    поскольку, если число x делится на другое число, то один из делителей гарантированно будет меньше или равен корню из x.
    """
    print('##### Простое ли число #####\n')
    number = isPrime_determination()
    isNumberPrime = isPrime(number)
    print(f'Число {number} {"является простым" if isNumberPrime else "не является простым"}')
    print('\n' + '#' * 20)


def T4_GCD():
    """
    НОД любой пары чисел, одним числом из которой будет 0, является второе число. Посколько 0 делится на что угодно, очевидно,
    что наибольшим делителем второго числа будет оно само. Для нахождения НОД пары чисел, где нет нуля можно выполнить циклический
    поиск остатка. НОД(a, b) = НОД(b, a % b) при a,b != 0. Такой алгоритм позволит дойти до состояния, когда одно из значений
    будет равно 0. Тогда НОД такой пары будет равняться второму числу. НОД можно применять к паре чисел, где одно является
    отрицательным, но результат будет всегда положительым. Наибольший делитель из -x и x всегда будет x.
    """
    print('##### Нахождение НОД пары чисел #####\n')
    number_1, number_2 = gcd_determination()
    gcd = greater_common_divisor(abs(number_1), abs(number_2))
    print(f'Наибольший общий делитель для пары {number_1} и {number_2} - это число {gcd}.')
    print('\n' + '#' * 20)


def T5_Cesar_Cypher():
    """
    Шифр цезаря представляет собой сдвиг букв по алфавину на x символов при шифровании и на -x символов при расшифровке
    сообщения. Можно в решении использовать таблицы юникод, где все буквы идут друг за другом, если бы не ё. Я пробовал
    учесть все случаю, связанные с буквой ё, но тогда код превращается в огромный набор условий и, кажется, становится
    ненадежным и уязвимым. Другим решением стало создание двух словарей. В первом ключами являются буквы, а значениями - цифры.
    Второй же словарь имеет обратную конструкцию. Проходя по каждому символу в сообщении происаходит проверка на букву.
    Если это буква, то в первом словаре по ключу ищется значение(номер в алфавите), прибавляется(вычитается если расшифровка)
    смещение и во втором словаре по ключу ищется новая буква.
    """
    print('##### Шифр Цезаря #####\n')
    alphabet = 'а, б, в, г, д, е, ё, ж, з, и, й, к, л, м, н, о, п, р, с, т, у, ф, х, ц, ч, ш, щ, ъ, ы, ь, э, ю, я'
    letters = alphabet.split(", ")
    string = string_input()
    bias = bias_input(letters)
    isEncryptionFlag = isEncryption()
    cesar_determination(string, bias, isEncryptionFlag, letters)
    print('\n' + '#' * 20)


def T6_Vigenere_cypher():
    """
    Шифр Виженера представляет собой усовершенствованный шифр Цезаря. С помощью кодового слова задается смещение. Дело в
    том, что номер буквы кодового слова по сути и является смещением. Зная номер буквы кодового слова, мы можем сместить
    по шифру Цезаря значение. Иначе говоря благодаря испоьлзованию кодового слова у нас для каждой буквы сообщения свой шифр
    Цезаря.

    В моем решении квадрат Виженера начинается с ROT1 ('a' = 'б'), но квадтар может начинаться и без смещения.
    """
    print('##### Шифр Виженера #####\n')
    alphabet = 'а, б, в, г, д, е, ё, ж, з, и, й, к, л, м, н, о, п, р, с, т, у, ф, х, ц, ч, ш, щ, ъ, ы, ь, э, ю, я'
    letters = alphabet.split(", ")
    string = string_input()
    code_word = code_word_input()
    isEncryptionFlag = isEncryption()
    vigenere_determination(string, code_word, isEncryptionFlag, letters)
    print('\n' + '#' * 20)


def T7_matrix_creation():
    """
    Без использования сторонних библиотек и тп матрица представляет собой двумерный список. С помощью двойных циклов по
    нему можно легко итерироваться и выполнять требуемые действия.
    """
    print('##### Создание матрицы #####\n')
    matrix_range_tuple = (-500, 500)
    the_process_of_matrix_creation(matrix_range_tuple)
    print('\n' + '#' * 20)


def T8_matrix_min_max():
    """
    Поскольку матрица - двумерный список, то мы просто можем брать каждую строку, искать в ней минимальное и максимальное
    значения и пересохранять в переменные, если они еще меньше или больше соответственно. Поскольку мы не знаем какие значения
    могут быть в матрице, то можно задать счетчику минимальных значений бесконечность, а счетчику максимальных значений - -бесконечность.
    На первой же итерации эти значения будут заменены на минимальное и максимальное в ряду значение соответственно.
    """
    print('##### Минимальное и максимальное значения матрицы #####\n')
    matrix_range_tuple = (-500, 500)
    matrix = the_process_of_matrix_creation(matrix_range_tuple)
    min, max = min_max_in_matrix(matrix)
    print(f'\nМинимальное значение: {min}',
          f'Максимальное значение: {max}.',
          sep=';\n')
    print('\n' + '#' * 20)


def T9_matrix_elements_sum():
    """
    Находим сумму матрицы, итерируюся по строкам и считая сумму элементов. Для того, чтобы посчтиать сумму в каждой колонке
    я использовал список на количество ячеек равное длине строки матрицы. Итерируясь по строкам складываем значение i-ого элемента
    строки с i-ым элементом ранее созданного списка. После окончания цикла имеем список, где i-ый элемент - сумма элементов
    i-ого столбца матрицы. Находим отношение. Поскольку по условию не написано, что матрица может быть заполнена только положительными
    значениями, то в некоторых случаях результатом может быть процент выше 100 и со знаком минус. Сумма элементов матрицы тоже
    может быть отрицательной. В зависимости от знака суммы знак процента может означать, что она более положительна или более отрицательна.
    Если модуль суммы колонки будет больше модуля суммы матрицы, то отношение перейдет за 100%, но это нормально поскольку присутствуют
    отрицательные числа.
    """
    print('##### Отношение суммы элементов каждого столбца к сумме элементов матрицы #####\n')
    matrix_range_tuple = (-10, 10)
    matrix = the_process_of_matrix_creation(matrix_range_tuple)
    elements_sum = matrix_elements_sum(matrix)
    column_sum = elements_in_column_sum(matrix)
    column_sum_percentage(elements_sum, column_sum)
    print('\n' + '#' * 20)


def T10_matrix_kCoulumn_multiplication():
    """
    Выбираем K-ый столбец и умножаем i-ый элемент столбца на все элементы i-ого ряда.
    """
    print('\nНеверно прочитал задание. Изначально реализовал умножение каждого элемента матрицы на соответствующий элемент k-ого столбца\n')
    matrix_range_tuple = (-10, 10)
    matrix = the_process_of_matrix_creation(matrix_range_tuple)
    column_number = matrix_column_determination(matrix)
    k_matrix = matrix_column_choice_return(matrix, column_number)
    k_matrix_message = 'K-матрица имеет вид: '
    matrix_show(k_matrix, k_matrix_message)
    new_matrix = k_matrix_multiplication(matrix, k_matrix)
    new_matrix_message = 'Итоговая матрица имеет вид: '
    matrix_show(new_matrix, new_matrix_message)
    inner_multiplication = k_column_inner_multiplication(k_matrix)
    print(f'\nПроизведение элементов k-ого столбца: {inner_multiplication}.')
    print('\n' + '#' * 20)


def T11_matrix_lRow_sum():
    """
    Выбираем l-ый ряд. Проходимся по каждому ряду матрицы, проходимся по каждому элементу ряда, запоминая id. Складываем
    i-ый элемент каждого ряда с i-ым элементом l-ряда.
    """
    print('\nНеверно прочитал задание. Изначально реализовал сумму каждого элемента матрицы с соответствующим элементом l-ого ряда\n')
    matrix_range_tuple = (-10, 10)
    matrix = the_process_of_matrix_creation(matrix_range_tuple)
    row_number = matrix_row_determination(matrix)
    l_matrix = matrix_row_choice_return(matrix, row_number)
    l_matrix_message = 'L-матрица имеет вид: '
    matrix_show([l_matrix],l_matrix_message)
    new_matrix = l_row_matrix_sum(matrix, l_matrix)
    new_matrix_message = 'Итоговая матрица имеет вид: '
    matrix_show(new_matrix, new_matrix_message)
    inner_sum = l_row_inner_sum(l_matrix)
    print(f'\nСумма элементов l-ого ряда: {inner_sum}.')
    print('\n' + '#' * 20)



def T12_matrix_target_search():
    """
    Я создал с помощью генератора список, где каждым элементом является индекс колонки в матрице. Итерируясь по рядам матрицы
    я ищу нужное значение. Если в ряду на i-ом индексе находится искомое число, то в моем списке возможных колонок я меняю значение
    этой колонки на None. После обхода ряда, удаляю все значения None. Мы не можем удалить сразу поскольку тогда мы выйдем за предел
    при итерации. В следующем ряду и последующих i-ые элементы я рассматривать не буду. Цикл идет либо до конца, либо заканчивается,
    если в каждом столбце нашлось значение. Такой подход минимизирует количество итераций, если искомые есть в каждом столбце и
    последний не находится в правом нижним углу матрицы. В противном случае он работает как обычное сравнение каждого элемента.
    """
    print('##### Поиск элемента в каждом столбце (хотя бы одно вхождение) #####\n')
    matrix_range_tuple = (0, 10)
    matrix = the_process_of_matrix_creation(matrix_range_tuple)
    target_value = searching_number_determination()
    searching_for_number_in_matrix(matrix, target_value)
    print('\n' + '#' * 20)


def T13_matrix_diagonals_sum():
    """
    У квадратной матрицы основная диагональ идет от значнения на позиции (0,0) до значения на позиции (i,k), где i = k.
    В прямоугольной матрице главная диагональ идет по координатам i и k, где i = k, но разница в том, что мы не попадем в
    правый нижний угол матрицы как в случае с квадратной. Побочная диагональ имеет тот же принцип, но стримится из левого
    нижнего угла в правый верхний(в квадратной матрице она его достигнет, в прямоугольной - нет). Я создал счетчик текущей
    позиции (i), которая изначально равна 0. В каждом ряду я беру i-ый элемент прибавляю к сумме и i += 1. Для побочной
    диагонали подход такой же, но начинаем с последнего ряда и идем к первому.
    """
    print('##### Нахождение сумм элементов на главной и побочной диагоналях матрицы #####\n')
    matrix_range_tuple = (-10, 10)
    matrix = the_process_of_matrix_creation(matrix_range_tuple)
    main_diagonal_sum = matrix_diagonal_sum(matrix, True)
    side_diagonal_sum = matrix_diagonal_sum(matrix, False)
    print(f'\nСумма элементов основной диагонали равна {main_diagonal_sum}',
          f'Сумма элементов побочной диагонали равна {side_diagonal_sum}',
          sep=';\n')
    print('\n' + '#' * 20)


def T14_matrix_column_additing():
    """
    Мое решение заключается в итерировании по рядам матрицы, подсчете количества 1, осознании четное оно или нет и в
    зависимости от этого, добавлении 1 или 0 в конец ряда.
    """
    print('##### Добавление колонки, которая делает четным количество 1 в строке #####\n')
    matrix_range_tuple = (0, 1)
    matrix = the_process_of_matrix_creation(matrix_range_tuple)
    matrix_adding_new_column(matrix)
    modified_matrix_message = 'Модифицированная матрица имеет вид:'
    matrix_show(matrix, modified_matrix_message)
    print('\n' + '#' * 20)


def menu():
    print(f'\n1. Рекурсивный бинарный поиск',
          f'2. Из десятичной в двоичную',
          f'3. Простое ли число',
          f'4. НОД',
          f'5. Шифрование/дешифрование (шифр Цезаря)',
          f'6. Шифрование/дешифрование (шифр Виженера)',
          f'7. Создание матрицы MxN',
          f'8. Минимальное и максимальное значения матрицы MxN',
          f'9. Сумма элементов матрицы MxN и доля суммы элементов столбцов',
          f'10. Перемножение матрицы с элемнтами K-ого столбца',
          f'11. Перемножение матрицы с элементами L-ого ряда',
          f'12. Найти хотя бы одно вхождение в столбце',
          f'13. Суммы элементов основной и побочной диагоналей',
          f'14. Добавление столбца',
          f'15. Завершить работу.\n',
          sep=';\n')

def switch_choice (case):
    match case:
        case 1:
            T1_recursive_binary_search ()
        case 2:
            T2_decimal_to_binary()
        case 3:
            T3_isPrime()
        case 4:
            T4_GCD()
        case 5:
            T5_Cesar_Cypher()
        case 6:
            T6_Vigenere_cypher()
        case 7:
            T7_matrix_creation()
        case 8:
            T8_matrix_min_max()
        case 9:
            T9_matrix_elements_sum()
        case 10:
            T10_matrix_kCoulumn_multiplication()
        case 11:
            T11_matrix_lRow_sum()
        case 12:
            T12_matrix_target_search()
        case 13:
            T13_matrix_diagonals_sum()
        case 14:
            T14_matrix_column_additing()
        case 15:
            return False


if __name__ == '__main__':
    while True:
        menu()
        try:
            choice = int(input("Пункт: "))
            isStopped = switch_choice(choice)
            if isStopped == False:
                 break
        except:
            print('Вы ввели некоретное значение.')
            continue

